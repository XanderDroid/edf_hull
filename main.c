#include <argp.h>
#include <getopt.h>
#include <math.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "edf_hull.h"
#include "ts_lib.h"

#define LEN(v) (sizeof(v) / sizeof(v[0]))

#define FILENAME "experim.csv"

#define EDFH_SEED 140
#define EDFH_NUM_TASKS 141
#define EDFH_PERIOD_MIN 142
#define EDFH_PERIOD_MAX 143
#define EDFH_PHASING 144
#define EDFH_RELATIVE_DL_AVG 145
#define EDFH_RELATIVE_DL_VAR 146
#define EDFH_EPS 147

/*
 * Brief list of options:
 *   'i': read task set from stdin
 *   's': random generation of one task set by a selected seed
 */

/*
 * Option 'i': apply the convex hull point reduction to the task set
 * read from stdin (from text file via stdin redirection). If the
 * option is "iv", then verbose output
 */
void main_input_task();

/*
 * Option 's': apply the convex hull point reduction to one task set
 * randomly generated by the random seed and the other settings passed
 * via stdin. If the option is "cv", then verbose output
 */
void main_seed(ts_rand_t rand_setup);

void print_rand_setup(ts_rand_t rand_setup);
int verify_arguments();
void edf_print_stats(edf_points_t *my_points, const ts_t *my_task_set, double time_points,
                     double time_qhull);
int verify_arg_int(char *arg);

/*Setting up program parser*/
const char *argp_program_version = "edf_hull 1.0\nCopyright information?";
static char doc[] =
    "Obtains the minimal set of constraints that guarantees EDF schedulability "
    "for a specified task set.\v"
    "When options 'i' nor 's' are included, or when FILE is not specified, the program"
    " reads input data from text file \"task_set.txt\" positioned in current directory.";
static char args_doc[] = "";

/*List of options supported by parser*/
struct argp_option options[] = {
    {0, 0, 0, 0, "Mode options:", 1},
    {"verbose", 'v', no_argument, 0, "Show verbose output."},
    {"input-file", 'i', "FILE", OPTION_ARG_OPTIONAL,
     "Apply the convex hull point "
     "reduction to the task set read from file."},
    /*Following arguments are required for randomized generation of the input data */
    {"random", 's', no_argument, 0,
     "Apply the convex hull point "
     "reduction to a task set randomly generated by seed."},
    {0, 0, 0, 0, "Mandatory options to include if task set is randomly generated:", 7},
    {"rand-seed", EDFH_SEED, "SEED", 0, "Specify seed used in task set generation."},
    {"num", EDFH_NUM_TASKS, "NUM_TASKS", 0, "Specify number of tasks in task set."},
    {"period-min", EDFH_PERIOD_MIN, "PERIOD_MIN", 0,
     "Specify the minimum period of a task within the task set."},
    {"period-max", EDFH_PERIOD_MAX, "PERIOD_MAX", 0,
     "Specify the maximum period of a task within the task set"},
    {"phasing", EDFH_PHASING, no_argument, 0,
     "Include offsets in generated task set(?). Phasing "
     "is by default absent."},
    {"relative-dl-avg", EDFH_RELATIVE_DL_AVG, "RELATIVE_DL_AVG", 0,
     "Specify the relative deadline average."},
    {"relative-dl-var", EDFH_RELATIVE_DL_VAR, "RELATIVE_DL_VAR", 0,
     "Specify the relative deadline variance."},
    {"eps", EDFH_EPS, "EPS", 0, "Specify sensitivity of the hyperperiod."},
    {0, 0, 0, 0, "Informational Options:", -1},
    {0}};

/* Used by main to communicate with parser. */
struct arguments {
    int verbose;
    enum { EDFH_FILE_MODE, EDFH_RANDOM_MODE } mode;
    char *input_data;
    ts_rand_t rand_setup;
};

/*
 * Parsing options and setting flags invoking the proper function depending of
 * the option. For any key value not recognized returns ARGP_ERR_UNKNOWN
 */
static error_t parser(int key, char *arg, struct argp_state *state) {
    struct arguments *arguments = state->input;
    switch (key) {
        case ARGP_KEY_INIT:
            arguments->input_data = "task_set.txt";
            arguments->verbose = false;
            /* Default mode is reading from input */
            arguments->mode = EDFH_FILE_MODE;
            break;
        case ARGP_KEY_END:
            /* Final argument validation*/
            if (arguments->mode == EDFH_RANDOM_MODE && !verify_arguments()) {
                argp_error(state, "Insufficient arguments for randomization.");
            }
            break;
        case 'v':
            arguments->verbose = true;
            break;
        case 'i':
            arguments->mode = EDFH_FILE_MODE;
            if (arg != NULL) {
                arguments->input_data = arg;
            }
            break;
        case 's':
            arguments->mode = EDFH_RANDOM_MODE;
            break;
        case EDFH_SEED:
            if (verify_arg_int(arg)) {
                sscanf(arg, "%d", &arguments->rand_setup.seed);
            } else {
                argp_error(state, "invalid input for random seed");
                return ARGP_KEY_ERROR;
            }
            break;
        case EDFH_NUM_TASKS:
            if (verify_arg_int(arg)) {
                sscanf(arg, "%d", &arguments->rand_setup.num);
            } else {
                argp_error(state, "invalid input for num");
            }
            break;
        case EDFH_PERIOD_MIN:
            sscanf(arg, "%lf", &arguments->rand_setup.per_min);
            break;
        case EDFH_PERIOD_MAX:
            sscanf(arg, "%lf", &arguments->rand_setup.per_max);
            break;
        case EDFH_PHASING:
            arguments->rand_setup.phasing = 1;
            break;
        case EDFH_RELATIVE_DL_AVG:
            sscanf(arg, "%lf", &arguments->rand_setup.norm_dl_avg);
            break;
        case EDFH_RELATIVE_DL_VAR:
            sscanf(arg, "%lf", &arguments->rand_setup.norm_dl_var);
            break;
        case EDFH_EPS:
            sscanf(arg, "%lf", &arguments->rand_setup.eps);
            break;
        default:
            return ARGP_ERR_UNKNOWN;
    }
    return 0;
}

/*Data type that contains all options and a pointer to a function that Argp will call to
assist in parsing */
struct argp argp = {options, parser, args_doc, doc, 0, 0, 0};

/*Contains arguments passed to command-line options*/
struct arguments arguments;

int main(int argc, char *argv[]) {
    if (argp_parse(&argp, argc, argv, 0, 0, &arguments) == ARGP_KEY_ERROR) {
        fprintf(stderr, "%s:%d: Error during parsing options .\n", __FILE__, __LINE__);
        exit(EXIT_FAILURE);
    }

    if (arguments.mode == EDFH_RANDOM_MODE) {
        main_seed(arguments.rand_setup);
    } else {
        main_input_task(arguments.input_data);
    }
}

/*
 * If task set is generated by seed, a number of parameters must be defined on command line by
 * the user. This function returns 1 if all of these arguments have been specified, 0 if not and
 * prints an error message to indicate the missing argument.
 */
int verify_arguments() {
    ts_rand_t *settings = &arguments.rand_setup;
    if (settings->seed == 0) {
        fprintf(stderr, "%s:%d: No seed specified. Please specify a seed (e.g --rand-seed 110).\n",
                __FILE__, __LINE__);
        return 0;
    }
    if (settings->num == 0) {
        fprintf(stderr,
                "%s:%d: Number of tasks invalid. Please specify a non-zero positive integer (e.g. "
                "--num 3).\n",
                __FILE__, __LINE__);
        return 0;
    }
    if (settings->per_min == 0) {
        fprintf(stderr,
                "%s:%d: Minimum period invalid. Please specify a positive number (e.g. "
                "--period-min 10).\n",
                __FILE__, __LINE__);
        return 0;
    }
    if (settings->per_max == 0) {
        fprintf(stderr,
                "%s:%d: Maximum period invalid. Please specify a positive number (e.g. "
                "--period-max 30).\n",
                __FILE__, __LINE__);
        return 0;
    }
    if (settings->norm_dl_avg == 0) {
        fprintf(stderr,
                "%s:%d: Relative deadline average invalid. Please specify a positive number (e.g. "
                "--relative-dl-avg 1).\n",
                __FILE__, __LINE__);
        return 0;
    }
    if (settings->norm_dl_var == 0) {
        fprintf(stderr,
                "%s:%d: Relative deadline variance invalid. Please specify a positive number (e.g. "
                "--relative-dl-var 0.1).\n",
                __FILE__, __LINE__);
        return 0;
    }
    if (settings->eps == 0) {
        fprintf(stderr,
                "%s:%d: Tolerance for hyperperiod equals zero. There may be issues with floating "
                "point.\n",
                __FILE__, __LINE__);
    }
    return 1;
}

int verify_arg_int(char *arg) {
    int i = 0;

    while (arg[i] != '\000') {
        if (!isdigit(arg[i])) {
            return 0;
        }
        i++;
    }
    return 1;
}

/* Prints the value of every parameter requested for the randomization of the task set. */
void print_rand_setup(ts_rand_t rand_setup) {
    printf("Input arguments:\n");
    printf(" seed:\t\t\t\t%u\n", rand_setup.seed);
    printf(" num tasks:\t\t\t%d\n", rand_setup.num);
    printf(" per min:\t\t\t%f\n", rand_setup.per_min);
    printf(" per max:\t\t\t%f\n", rand_setup.per_max);
    printf(" phasing:\t\t\t%s\n", rand_setup.phasing ? "yes" : "no");
    printf(" relative dl avg:\t\t%f\n", rand_setup.norm_dl_avg);
    printf(" relative dl var:\t\t%f\n", rand_setup.norm_dl_var);
    printf(" eps:\t\t\t\t%f\n\n", rand_setup.eps);
}

void main_input_task(char *input_filename) {
    ts_t my_task_set;
    edf_points_t my_points;
    struct timespec start, check;
    double time_points, time_qhull;

    /* Initialization */
    ts_set_zero(&my_task_set);
    edf_set_zero(&my_points);

    ts_read_alloc(&my_task_set, input_filename);
    if (arguments.verbose) {
        /* verbose output */
        printf("Input filename : %s\n", input_filename);
        ts_print(&my_task_set);
    }
    clock_gettime(CLOCK_MONOTONIC, &start);
    edf_create_points(&my_task_set, &my_points);
    clock_gettime(CLOCK_MONOTONIC, &check);
    time_points = (check.tv_nsec - start.tv_nsec) * 1e-9 + (check.tv_sec - start.tv_sec);
    if (arguments.verbose) {
        /* verbose output */
        edf_print_points(&my_points);
    }
    time_qhull = edf_qhull_points(&my_points);
    edf_print_constraints_C(&my_points);
    edf_print_constraints_U(&my_task_set, &my_points);
    edf_print_stats(&my_points, &my_task_set, time_points, time_qhull);
    edf_free_points(&my_points);
    ts_free(&my_task_set);
}

void main_seed(ts_rand_t rand_setup) {
    ts_t my_task_set;
    edf_points_t my_points;
    int num_tasks;
    char *s = NULL;
    size_t dim = 0;
    int i = 0;
    struct timespec start, check;
    double time_points, time_qhull;

    /* Initialization */
    ts_set_zero(&my_task_set);
    edf_set_zero(&my_points);

    /* only method implemented for period generation */
    rand_setup.per_m = per_unif;

    /* Generate the task set */
    ts_rand(&my_task_set, &rand_setup);
    if (arguments.verbose) {
        /* verbose output */
        print_rand_setup(arguments.rand_setup);
        ts_print(&my_task_set);
    }
    clock_gettime(CLOCK_MONOTONIC, &start);
    edf_create_points(&my_task_set, &my_points);
    clock_gettime(CLOCK_MONOTONIC, &check);
    time_points = (check.tv_nsec - start.tv_nsec) * 1e-9 + (check.tv_sec - start.tv_sec);
    if (arguments.verbose) {
        /* verbose output */
        edf_print_points(&my_points);
    }
    time_qhull = edf_qhull_points(&my_points);
    edf_print_constraints_C(&my_points);
    edf_print_constraints_U(&my_task_set, &my_points);
    edf_print_stats(&my_points, &my_task_set, time_points, time_qhull);
    edf_free_points(&my_points);
    ts_free(&my_task_set);
}

void edf_print_stats(edf_points_t *my_points, const ts_t *my_task_set, double time_points,
                     double time_qhull) {
    printf("\nNumber of total constraints:\t\t%d\n", my_points->num_points);
    printf("Number of minimal constraints:\t\t%d\n", my_points->num_sel);
    printf("Fraction of necessary constraints:\t%f\n",
           my_points->num_sel / (double)my_points->num_points);
    if (arguments.verbose) {
        printf("Time points: %f secs\nTime qhull: %f secs\n", time_points, time_qhull);
    }
}

#if 0
int main_spanDL(int argc, char* argv[])
{
#define NUM_TASKS 6

	ts_t         my_task_set;
	ts_rand_t    rand_setup;
	edf_points_t my_points;
	double max_d, max_o;
	struct timespec start, check;
	double time_points, time_qhull;
	double dl_span[] = {0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, 1.5};
	double var_span[] = {0.4, 0.3, 0.2, 0.1, 0};
	int i, j, k, iter=0;
	double cur_dl, min_dl, max_dl;

	if (argc >= 2) {
		fdata = fopen(argv[1],"a");
	} else {
		fdata = fopen(FILENAME,"a");
	}

	my_task_set.num = 0;
	my_task_set.per = NULL;
	my_task_set.dl = NULL;
	my_task_set.phi = NULL;
	rand_setup.per_m = per_unif;
	rand_setup.per_min = 2;
	rand_setup.per_max = 20;
	rand_setup.norm_dl_avg = 0.5;
	rand_setup.norm_dl_var = 0.2;
	rand_setup.phasing = 0;
	my_points.alloc_points = 0;
	my_points.t0 = NULL;
	my_points.t1 = NULL;
	my_points.vec_p = NULL;
	my_points.qh_vec_p = NULL;
	my_points.num_sel = 0;
	my_points.vec_sel = NULL;
	srand(time(NULL));
	while (1) {
		for(i=0; i<LEN(dl_span); i++) {
			rand_setup.norm_dl_avg = dl_span[i];
			for(j=0; j<LEN(var_span); j++) {
				rand_setup.norm_dl_var = var_span[j];
				if (rand_setup.norm_dl_avg-rand_setup.norm_dl_var >= 1-1e-8) {
					/* All tasks with deadline >= period */
					continue;
				}
				if (rand_setup.norm_dl_avg+rand_setup.norm_dl_var <= 1.1) {
					/* Constrained deadline
					   tasks. They seem to be
					   easier: SKIPPING */
					continue;
				}
				while(1) {
					rand_setup.seed = rand();
					ts_rand(&my_task_set, &rand_setup, NUM_TASKS);
					/*  min/max deadline/period */
					max_dl = min_dl =
						my_task_set.dl[0]/ my_task_set.per[0];
					for (k=1; k<my_task_set.num; k++) {
						cur_dl = my_task_set.dl[k]/my_task_set.per[k];
						if (cur_dl < min_dl)
							min_dl = cur_dl;
						if (cur_dl > max_dl)
							max_dl = cur_dl;
					}
					if (max_dl < 0.9 || min_dl >=1)
						/* Hardest seems to be
						 * a mixture of arb
						 * and constrained
						 * DL */
						continue;
					if (fabs(my_task_set.h_per_tol) <= 1e-20)
						/* Keep only if hyperP exact */
						break;
				}
				fprintf(fdata, "%u,%u,%f,%f,%u,%f,%f,%f,",
					rand_setup.seed, rand_setup.num_tasks,
					rand_setup.per_min, rand_setup.per_max, rand_setup.phasing,
					rand_setup.norm_dl_avg, rand_setup.norm_dl_var,
					my_task_set.h_per);
				fflush(fdata);
				clock_gettime(CLOCK_MONOTONIC, &start);
				edf_create_points(&my_task_set, &my_points);
				clock_gettime(CLOCK_MONOTONIC, &check);
				time_points = (check.tv_nsec-start.tv_nsec)*1e-9
					+(check.tv_sec-start.tv_sec);
				edf_qhull_points(&my_points);
				clock_gettime(CLOCK_MONOTONIC, &check);
				time_qhull = (check.tv_nsec-start.tv_nsec)*1e-9
					+(check.tv_sec-start.tv_sec)-time_points;
				fprintf(fdata, "%u,%u,%f,%f\n",
					my_points.num_points, my_points.num_sel,
					time_points, time_qhull);
			}
		}
		printf("%d\t", ++iter);
	}
}
#endif

#if 0
int main_span_per(int argc, char* argv[])
/*int main(int argc, char* argv[])*/
{
	ts_t         my_task_set;
	ts_rand_t    rand_setup;
	edf_points_t my_points;
	double max_d, max_o;
	struct timespec start, check;
	double time_points, time_qhull;
	int num_span[] = {4};
	int i, j, k, iter=0;
	double cur_dl, min_dl, max_dl;

	if (argc >= 2) {
		fdata = fopen(argv[1],"a");
	} else {
		fdata = fopen(FILENAME,"a");
	}

	/* Initialization */
	my_task_set.num = 0;
	my_task_set.per = NULL;
	my_task_set.dl = NULL;
	my_task_set.phi = NULL;
	rand_setup.per_m = per_unif;
	rand_setup.num_tasks = 4;  /* to be changed in this experiment */
	rand_setup.per_min = 2;
	rand_setup.per_max = 200;
	rand_setup.norm_dl_avg = 1;
	rand_setup.norm_dl_var = 0.4;
	rand_setup.phasing = 0;
	my_points.alloc_points = 0;
	my_points.t0 = NULL;
	my_points.t1 = NULL;
	my_points.vec_p = NULL;
	my_points.qh_vec_p = NULL;
	my_points.num_sel = 0;
	my_points.vec_sel = NULL;
	srand(time(NULL));
	while (1) {
		for(i=0; i<LEN(num_span); i++) {
			rand_setup.num_tasks = num_span[i];
			while(1) {
				rand_setup.seed = rand();
				ts_rand(&my_task_set, &rand_setup);
				/*  min/max deadline/period */
				max_dl = min_dl =
					my_task_set.dl[0]/ my_task_set.per[0];
				for (k=1; k<my_task_set.num; k++) {
					cur_dl = my_task_set.dl[k]/my_task_set.per[k];
					if (cur_dl < min_dl)
						min_dl = cur_dl;
					if (cur_dl > max_dl)
						max_dl = cur_dl;
				}
				if (max_dl < 0.9 || min_dl >=1)
					/* Hardest seems to be a
					 * mixture of arb and
					 * constrained DL */
					continue;
				if (fabs(my_task_set.h_per_tol) <= 1e-20)
					/* Keep only if hyperP exact */
					break;
			}
			fprintf(fdata, "%u,%u,%f,%f,%u,%f,%f,%f,",
				rand_setup.seed, rand_setup.num_tasks,
				rand_setup.per_min, rand_setup.per_max, rand_setup.phasing,
				rand_setup.norm_dl_avg, rand_setup.norm_dl_var,
				my_task_set.h_per);
			fflush(fdata);
			clock_gettime(CLOCK_MONOTONIC, &start);
			edf_create_points(&my_task_set, &my_points);
			clock_gettime(CLOCK_MONOTONIC, &check);
			time_points = (check.tv_nsec-start.tv_nsec)*1e-9
				+(check.tv_sec-start.tv_sec);
			edf_qhull_points(&my_points);
			clock_gettime(CLOCK_MONOTONIC, &check);
			time_qhull = (check.tv_nsec-start.tv_nsec)*1e-9
				+(check.tv_sec-start.tv_sec)-time_points;
			fprintf(fdata, "%u,%u,%f,%f\n",
				my_points.num_points, my_points.num_sel,
				time_points, time_qhull);
		}
		/*printf("%d\t", ++iter); */
	}
}
#endif

#if 0
int main_num(int argc, char* argv[])
/*int main(int argc, char* argv[])*/
{
	ts_t         my_task_set;
	ts_rand_t    rand_setup;
	edf_points_t my_points;
	double max_d, max_o;
	struct timespec start, check;
	double time_points, time_qhull;
	int num_span[] = {8, 7, 6, 5, 4, 3, 2};
	int i, j, k, iter=0;
	double cur_dl, min_dl, max_dl;

	if (argc >= 2) {
		fdata = fopen(argv[1],"a");
	} else {
		fdata = fopen(FILENAME,"a");
	}

	/* Initialization */
	my_task_set.num = 0;
	my_task_set.per = NULL;
	my_task_set.dl = NULL;
	my_task_set.phi = NULL;
	rand_setup.per_m = per_unif;
	rand_setup.num_tasks = 3;  /* to be changed in this experiment */
	rand_setup.per_min = 2;
	rand_setup.per_max = 1000;  /* to be changed in this experiment */
	rand_setup.norm_dl_avg = 1;
	rand_setup.norm_dl_var = 0.4;
	rand_setup.phasing = 0;
	my_points.alloc_points = 0;
	my_points.t0 = NULL;
	my_points.t1 = NULL;
	my_points.vec_p = NULL;
	my_points.qh_vec_p = NULL;
	my_points.num_sel = 0;
	my_points.vec_sel = NULL;
	srand(time(NULL));
	while (1) {
		for(i=0; i<LEN(num_span); i++) {
			rand_setup.num_tasks = num_span[i];
			rand_setup.per_max = ceil(pow(1e6,1.0/(double)num_span[i]))+10;
			while(1) {
				rand_setup.seed = rand();
				ts_rand(&my_task_set, &rand_setup);
				/*  min/max deadline/period */
				max_dl = min_dl =
					my_task_set.dl[0]/ my_task_set.per[0];
				for (k=1; k<my_task_set.num; k++) {
					cur_dl = my_task_set.dl[k]/my_task_set.per[k];
					if (cur_dl < min_dl)
						min_dl = cur_dl;
					if (cur_dl > max_dl)
						max_dl = cur_dl;
				}
				if (max_dl < 0.9 || min_dl >=1)
					/* Hardest seems to be a
					 * mixture of arb and
					 * constrained DL */
					continue;
				if (fabs(my_task_set.h_per_tol) <= 1e-20)
					/* Keep only if hyperP exact */
					break;
			}
			fprintf(fdata, "%u,%u,%f,%f,%u,%f,%f,%f,",
				rand_setup.seed, rand_setup.num_tasks,
				rand_setup.per_min, rand_setup.per_max, rand_setup.phasing,
				rand_setup.norm_dl_avg, rand_setup.norm_dl_var,
				my_task_set.h_per);
			fflush(fdata);
			clock_gettime(CLOCK_MONOTONIC, &start);
			edf_create_points(&my_task_set, &my_points);
			clock_gettime(CLOCK_MONOTONIC, &check);
			time_points = (check.tv_nsec-start.tv_nsec)*1e-9
				+(check.tv_sec-start.tv_sec);
			edf_qhull_points(&my_points);
			clock_gettime(CLOCK_MONOTONIC, &check);
			time_qhull = (check.tv_nsec-start.tv_nsec)*1e-9
				+(check.tv_sec-start.tv_sec)-time_points;
			fprintf(fdata, "%u,%u,%f,%f\n",
				my_points.num_points, my_points.num_sel,
				time_points, time_qhull);
		}
		/*printf("%d\t", ++iter); */
	}
}
#endif
